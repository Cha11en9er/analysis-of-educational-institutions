"""
================================================================================
АНАЛИЗ ИНФРАСТРУКТУРЫ ОБРАЗОВАТЕЛЬНЫХ УЧРЕЖДЕНИЙ
================================================================================

ОПИСАНИЕ РАБОТЫ СКРИПТА:

Этот скрипт выполняет комплексный анализ инфраструктуры образовательных 
учреждений (школ) на основе данных о зданиях. Основные этапы работы:

1. ЗАГРУЗКА И ПОДГОТОВКА ДАННЫХ:
   - Чтение данных из Excel файла (лист 'schools')
   - Очистка и преобразование типов данных
   - Нормализация числовых значений (замена запятых на точки)
   - Преобразование текстовых значений наличия объектов в бинарный формат

2. РАСЧЕТ ИНФРАСТРУКТУРНОГО СКОРА:
   Скрипт создает комплексный показатель "Инфраструктурный скор", который
   состоит из трех компонентов:
   
   a) СОВРЕМЕННОСТЬ (вес 40%):
      - Учитывает год постройки и год реконструкции здания
      - Чем новее здание, тем выше балл
      - Используется максимальный год из двух (постройка/реконструкция)
   
   b) МАСШТАБ (вес 20%):
      - Учитывает площадь здания (S, м2) и количество этажей
      - Значения нормализуются от 0 до 100
      - Большие здания получают более высокий балл
   
   c) ОСНАЩЕННОСТЬ (вес 40%):
      - Оценивает наличие спортивных объектов:
        * Бассейн: 25 баллов
        * Стадион: 20 баллов
        * ФОК (Физкультурно-оздоровительный комплекс): 15 баллов
        * Спортплощадка: 10 баллов
      - Баллы суммируются, если объект присутствует

3. КЛАСТЕРИЗАЦИЯ ШКОЛ:
   - Используется алгоритм K-Means для группировки школ по схожести
   - Кластеризация выполняется на основе всех компонентов скора
   - Данные предварительно масштабируются (StandardScaler)
   - Результат: 4 кластера школ с различными характеристиками

4. АНАЛИЗ РЕЗУЛЬТАТОВ:
   - Вывод топ-10 школ по инфраструктурному скору
   - Статистика по кластерам (средние значения показателей)
   - Примеры школ в каждом кластере

5. СОХРАНЕНИЕ РЕЗУЛЬТАТОВ:
   - Результаты сохраняются в Excel файл в лист 'schools_1_stage'
   - Сохраняются все исходные данные + новые расчетные поля

СОЗДАВАЕМЫЕ ПОЛЯ В EXCEL (лист 'schools_1_stage'):

Все исходные поля из листа 'schools' + следующие новые поля:

1. modernity_score (0-100):
   - Скор современности здания
   - Чем новее здание, тем выше значение
   - Учитывает год постройки и реконструкции
   - Применение: оценка физического состояния здания

2. scale_score (0-100):
   - Скор масштаба здания
   - Учитывает площадь и этажность
   - Большие здания имеют более высокий скор
   - Применение: оценка размеров и вместимости школы

3. amenities_score (0-70):
   - Скор оснащенности спортивными объектами
   - Бассейн: +25, Стадион: +20, ФОК: +15, Спортплощадка: +10
   - Применение: оценка спортивной инфраструктуры

4. Infrastructure_Score (0-100):
   - ИТОГОВЫЙ инфраструктурный скор
   - Формула: modernity*0.4 + scale*0.2 + amenities*0.4
   - Применение: комплексная оценка инфраструктуры школы

5. Effective_Year:
   - Эффективный год здания (максимум из года постройки и реконструкции)
   - Применение: определение актуального состояния здания

6. Age:
   - Возраст здания в годах (от Effective_Year до текущего года)
   - Применение: анализ износа и необходимости ремонта

7. Cluster (0-3):
   - Номер кластера школы (результат кластеризации K-Means)
   - Применение: группировка школ по схожести инфраструктуры

8. Cluster_Name:
   - Название кластера:
     * 0: "Крепкие середняки"
     * 1: "Новые и крупные комплексы"
     * 2: "Старый фонд с базовой инфраструктурой"
     * 3: "Школы с уникальным оснащением (бассейны, стадионы)"
   - Применение: категоризация школ для сравнительного анализа

ПРИМЕНЕНИЕ ВМЕСТЕ С АНАЛИЗОМ ОТЗЫВОВ (fa_main.py):

Созданные поля можно использовать для комплексного анализа школ:

1. КОРРЕЛЯЦИОННЫЙ АНАЛИЗ:
   - Сравнить Infrastructure_Score с рейтингами из отзывов
   - Выявить связь между физической инфраструктурой и удовлетворенностью
   - Найти школы с высоким скором, но низкими рейтингами (проблемы в других сферах)

2. АНАЛИЗ ПО КЛАСТЕРАМ:
   - Сгруппировать отзывы по кластерам школ
   - Сравнить тональность отзывов в разных кластерах
   - Выявить специфические проблемы для каждого типа школ:
     * "Старый фонд" - больше жалоб на ремонт
     * "Новые комплексы" - больше отзывов об инфраструктуре
     * "С уникальным оснащением" - больше упоминаний спорта

3. ТЕМАТИЧЕСКИЙ АНАЛИЗ:
   - Связать темы отзывов с полями скора:
     * modernity_score ↔ тема "ремонт" (старые здания = больше жалоб)
     * amenities_score ↔ тема "инфраструктура" (наличие объектов = упоминания)
     * scale_score ↔ тема "пространство" (размер здания = комфорт)

4. ВРЕМЕННОЙ АНАЛИЗ:
   - Сравнить Age здания с динамикой рейтингов
   - Выявить школы, где реконструкция (Effective_Year) повлияла на отзывы
   - Проанализировать, как возраст здания влияет на тональность отзывов

5. ПРИОРИТИЗАЦИЯ ВНИМАНИЯ:
   - Школы с низким Infrastructure_Score + отрицательные отзывы = приоритет
   - Школы с высоким скором, но проблемами в отзывах = особое внимание
   - Кластеры с наибольшим количеством жалоб = целевые программы

6. ПРЕДИКТИВНЫЙ АНАЛИЗ:
   - Использовать Infrastructure_Score для прогнозирования рейтингов
   - Выявить школы, где инфраструктура не соответствует ожиданиям
   - Определить оптимальные инвестиции на основе скоров и отзывов

ПРИМЕР ИСПОЛЬЗОВАНИЯ:
   - Загрузить данные из 'schools_1_stage' и отзывы из fa_main.py
   - Объединить по ID школы
   - Создать дашборд: Infrastructure_Score vs средний рейтинг отзывов
   - Проанализировать темы отзывов в контексте кластеров
   - Выявить школы-кандидаты на реконструкцию или улучшение

ИСПОЛЬЗУЕМЫЕ БИБЛИОТЕКИ:
- pandas: работа с данными (DataFrame)
- numpy: численные операции
- sklearn: машинное обучение (нормализация, кластеризация)
- openpyxl: работа с Excel файлами

================================================================================
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler, StandardScaler
from sklearn.cluster import KMeans
import os
from openpyxl import load_workbook

# --- 1. ЗАГРУЗКА И ПОДГОТОВКА ДАННЫХ ---

# Путь к файлу с данными
excel_file_path = r'C:\repos\analysis-of-educational-institutions\global_data\Здания школ.xlsx'
sheet_name = 'schools'

# Чтение данных из Excel файла
print(f"Загрузка данных из файла: {excel_file_path}")
print(f"Лист: {sheet_name}")
df = pd.read_excel(excel_file_path, sheet_name=sheet_name)
print(f"Загружено записей: {len(df)}")
print(f"Колонок: {len(df.columns)}")

# Очистка и преобразование типов данных
def clean_data(df):
    # Преобразуем числовые колонки, заменяя запятые на точки
    for col in ['S, м2', 'Рейтинг 2ГИС', 'Рейтинг Яндекс']:
        df[col] = pd.to_numeric(df[col].astype(str).str.replace(',', '.'), errors='coerce')

    # Преобразуем годы в числовой формат, ошибки заменяем на NaN
    for col in ['г/пост', 'реконструкция']:
        df[col] = pd.to_numeric(df[col], errors='coerce')
        
    # Преобразуем наличие объектов в бинарный формат (1 - есть, 0 - нет)
    for col in ['ФОК', 'бассейн', 'стадион', 'спортплощадка']:
        df[col] = df[col].apply(lambda x: 1 if isinstance(x, str) and 'есть' in x else 0)

    # Заполняем пропуски в ключевых числовых колонках для расчетов
    df['Этажей'] = df['Этажей'].fillna(df['Этажей'].median())
    
    return df

df = clean_data(df)

# --- 2. СОЗДАНИЕ "ИНФРАСТРУКТУРНОГО СКОРА" ---

# Задаем константы и веса для расчета
CURRENT_YEAR = 2025 # Как указано в задании
WEIGHTS = {
    'modernity': 0.4, # Вес современности здания
    'scale': 0.2,     # Вес масштаба (размера)
    'amenities': 0.4  # Вес оснащенности
}
AMENITIES_POINTS = {
    'бассейн': 25,
    'стадион': 20,
    'ФОК': 15,
    'спортплощадка': 10
}

# Расчет компонента "Современность"
# Чем новее здание или его реконструкция, тем выше балл
df['Effective_Year'] = df[['г/пост', 'реконструкция']].max(axis=1)
df['Age'] = CURRENT_YEAR - df['Effective_Year']
# Избегаем деления на ноль, если все школы одного года
min_age = df['Age'].min() - 1 if df['Age'].min() != df['Age'].max() else df['Age'].min() - 2
df['modernity_score'] = 100 * (1 - (df['Age'] - min_age) / (df['Age'].max() - min_age))
df['modernity_score'] = df['modernity_score'].fillna(0) # Если год не указан, балл = 0

# Расчет компонента "Масштаб"
# Используем площадь и этажность, нормализуем от 0 до 100
scaler = MinMaxScaler(feature_range=(0, 100))
# Нормализуем каждую колонку отдельно и берем среднее значение
scaled_data = scaler.fit_transform(df[['S, м2', 'Этажей']].fillna(0))
df['scale_score'] = scaled_data.mean(axis=1)  # Среднее значение двух нормализованных признаков

# Расчет компонента "Оснащенность"
df['amenities_score'] = (
    df['бассейн'] * AMENITIES_POINTS['бассейн'] +
    df['стадион'] * AMENITIES_POINTS['стадион'] +
    df['ФОК'] * AMENITIES_POINTS['ФОК'] +
    df['спортплощадка'] * AMENITIES_POINTS['спортплощадка']
)

# Итоговый "Инфраструктурный скор"
df['Infrastructure_Score'] = (
    df['modernity_score'] * WEIGHTS['modernity'] +
    df['scale_score'] * WEIGHTS['scale'] +
    df['amenities_score'] * WEIGHTS['amenities']
).round(2)


# --- 3. КЛАСТЕРИЗАЦИЯ ШКОЛ ---

# Выбираем признаки для кластеризации
features_for_clustering = ['modernity_score', 'scale_score', 'amenities_score', 'Infrastructure_Score']
X = df[features_for_clustering].fillna(0)

# Масштабируем данные, чтобы все признаки имели одинаковое влияние
scaler_cluster = StandardScaler()
X_scaled = scaler_cluster.fit_transform(X)

# Определяем количество кластеров (можно подбирать, например, методом "локтя")
# Возьмем 4 для примера: "элитные", "крепкие середняки", "старый фонд", "компактные/специализированные"
kmeans = KMeans(n_clusters=4, random_state=42, n_init=10)
df['Cluster'] = kmeans.fit_predict(X_scaled)


# --- 4. АНАЛИЗ РЕЗУЛЬТАТОВ ---

print("--- Топ-10 школ по Инфраструктурному скору ---")
top_schools = df.sort_values('Infrastructure_Score', ascending=False).head(10)
print(top_schools[['Короткое название', 'Infrastructure_Score', 'modernity_score', 'scale_score', 'amenities_score', 'г/пост', 'реконструкция']])

print("\n\n--- Анализ кластеров школ ---")
cluster_analysis = df.groupby('Cluster')[['Infrastructure_Score', 'modernity_score', 'scale_score', 'amenities_score', 'S, м2', 'Age']].mean().round(2)
cluster_analysis['Count'] = df['Cluster'].value_counts()
print(cluster_analysis)

# Добавляем интерпретацию кластеров
cluster_names = {
    0: "Крепкие середняки",
    1: "Новые и крупные комплексы",
    2: "Старый фонд с базовой инфраструктурой",
    3: "Школы с уникальным оснащением (бассейны, стадионы)"
}
# Примечание: эти названия могут потребовать корректировки после анализа средних значений
df['Cluster_Name'] = df['Cluster'].map(cluster_names)

print("\n\n--- Пример школ по кластерам ---")
for i in range(4):
    print(f"\nКластер {i} ({cluster_names.get(i, 'N/A')}):")
    print(df[df['Cluster'] == i][['Короткое название', 'Infrastructure_Score']].head(3))


# --- 5. СОХРАНЕНИЕ РЕЗУЛЬТАТОВ В EXCEL ---

# Подготавливаем данные для сохранения: все исходные колонки + новые поля скора
# Выбираем колонки для сохранения
columns_to_save = list(df.columns)

# Создаем копию датафрейма для сохранения
df_output = df.copy()

# Упорядочиваем колонки: сначала исходные, потом новые поля скора
# Определяем исходные колонки (все кроме новых полей скора)
original_columns = [col for col in df.columns if col not in [
    'modernity_score', 'scale_score', 'amenities_score', 'Infrastructure_Score',
    'Effective_Year', 'Age', 'Cluster', 'Cluster_Name'
]]

# Новые колонки со скорами
score_columns = [
    'modernity_score', 'scale_score', 'amenities_score', 'Infrastructure_Score',
    'Effective_Year', 'Age', 'Cluster', 'Cluster_Name'
]

# Формируем финальный порядок колонок
final_columns = original_columns + [col for col in score_columns if col in df.columns]

# Переупорядочиваем колонки
df_output = df_output[final_columns]

# Сохраняем в Excel файл в новый лист
print("\n\n--- Сохранение результатов в Excel ---")
try:
    # Загружаем существующий файл для проверки и удаления старого листа
    book = load_workbook(excel_file_path)
    
    # Удаляем лист, если он уже существует
    if 'schools_1_stage' in book.sheetnames:
        book.remove(book['schools_1_stage'])
        print("  Удален существующий лист 'schools_1_stage'")
    
    # Сохраняем изменения
    book.save(excel_file_path)
    book.close()
    
    # Теперь записываем данные в новый лист
    with pd.ExcelWriter(excel_file_path, mode='a', engine='openpyxl', if_sheet_exists='replace') as writer:
        df_output.to_excel(writer, sheet_name='schools_1_stage', index=False)
    
    print(f"✓ Результаты успешно сохранены в лист 'schools_1_stage' файла:")
    print(f"  {excel_file_path}")
    print(f"✓ Всего записей: {len(df_output)}")
    print(f"✓ Всего колонок: {len(df_output.columns)}")
    print(f"✓ Добавлены поля скора: modernity_score, scale_score, amenities_score, Infrastructure_Score")
    print(f"✓ Добавлены поля анализа: Effective_Year, Age, Cluster, Cluster_Name")
except PermissionError:
    print(f"⚠ Ошибка: Файл {excel_file_path} открыт в другой программе.")
    print("   Закройте файл в Excel и запустите скрипт снова.")
except FileNotFoundError:
    print(f"⚠ Ошибка: Файл {excel_file_path} не найден.")
    print("   Проверьте путь к файлу.")
except Exception as e:
    print(f"⚠ Ошибка при сохранении в Excel: {e}")
    print("Попытка сохранить в новый файл...")
    # Если не удалось открыть в режиме добавления, создаем новый файл
    output_file = excel_file_path.replace('.xlsx', '_with_scores.xlsx')
    df_output.to_excel(output_file, sheet_name='schools_1_stage', index=False)
    print(f"✓ Результаты сохранены в новый файл: {output_file}")
